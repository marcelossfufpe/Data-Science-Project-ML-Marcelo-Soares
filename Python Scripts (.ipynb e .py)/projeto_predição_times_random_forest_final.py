# -*- coding: utf-8 -*-
"""Projeto_Predição_Times_Random_Forest---final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VMgQW2Oh-x-FHO5c_NrK1Cw_zrTN4_-4
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install pandas scikit-learn
# %pip install pycaret --quiet

from pycaret.classification import *
from sklearn.tree import plot_tree
from sklearn.metrics import confusion_matrix, accuracy_score, cohen_kappa_score, classification_report
from sklearn.model_selection import train_test_split
import seaborn as sns

# <> Bibliotecas de Visualização
import seaborn as sns
from matplotlib.pyplot import figure as pltfigure
import matplotlib.pyplot as plt

# <> Biliotecas para manipulação com dados
import pandas as pd

# Carregar o dataset de partidas (Match.csv)
matches = pd.read_csv('Match.csv')

# Carregar o dataset de times (Team.csv)
teams = pd.read_csv('Team.csv')

# Carregar o dataset de ligas (League.csv)
leagues = pd.read_csv('League.csv')

leagues.head()
#print(leagues['name'].unique())

# Filtrar a Premier League
selectedLeagues = leagues[leagues['name'].isin(['England Premier League', 'Italy Serie A', 'Germany 1. Bundesliga'])]
selectedLeaguesId = selectedLeagues['id'].values

#Filtrar as partidas de Match apenas para as ligas de interessa
filteredMatches = matches[matches['league_id'].isin(selectedLeaguesId)]

# Verificar colunas para identificar quais são de interesse
matches.columns
# teams.columns

# Unir dados apenas das colunas importantes em um único df, tanto de Matches quanto Teams
filteredMatches = filteredMatches[['season','date', 'home_team_api_id', 'away_team_api_id', 'home_team_goal', 'away_team_goal', 'league_id']]

selectedTeams = teams[['team_api_id', 'team_long_name']]

# Unindo informações dos times com as partidas (separando entre times da casa e fora, pois para cada partida, deve conter duas entradas: um para time da casa e outro para visitante)
mergedDataHome = pd.merge(filteredMatches, selectedTeams, how='left', left_on='home_team_api_id', right_on='team_api_id')
mergedDataHome.rename(columns={'team_long_name': 'home_team_name'}, inplace=True) #Renomeando para explicitar o nome do time da casa
mergedDataHome.drop('team_api_id', axis=1, inplace=True) #Retirando a coluna pois é reduntante, pois já tem no data frame

mergedData = pd.merge(mergedDataHome, selectedTeams, how='left', left_on='away_team_api_id', right_on='team_api_id')
mergedData.rename(columns={'team_long_name': 'away_team_name'}, inplace=True)
mergedData.drop('team_api_id', axis=1, inplace=True)

mergedDataHome.head()
mergedData.head()

mergedDataHome.dtypes

# Calcular gols marcados e sofridos por cada time e adicionar à tabela
def calculate_goals(df):
    df['home_goals_scored'] = df['home_team_goal']
    df['home_goals_conceded'] = df['away_team_goal']

    df['away_goals_scored'] = df['away_team_goal']
    df['away_goals_conceded'] = df['home_team_goal']

    return df

mergedData = calculate_goals(mergedData)

# Agrupar para somar os gols totais por time

# Agrupar por time e temporada para somar os gols marcados e sofridos
homeGoal = mergedData.groupby(['season', 'home_team_name'])[['home_goals_scored', 'home_goals_conceded']].sum().reset_index()
awayGoals = mergedData.groupby(['season', 'away_team_name'])[['away_goals_scored', 'away_goals_conceded']].sum().reset_index()

# Renomear colunas para facilitar a junção
homeGoal.rename(columns={'home_team_name': 'team_name'}, inplace=True)
awayGoals.rename(columns={'away_team_name': 'team_name'}, inplace=True)

# Combinar os gols de casa e fora em uma única tabela
totalGoals = pd.merge(homeGoal, awayGoals, on=['season', 'team_name'], how='outer')

# Somar os gols marcados e sofridos
totalGoals['goals_scored'] = totalGoals['home_goals_scored'] + totalGoals['away_goals_scored']
totalGoals['goals_conceded'] = totalGoals['home_goals_conceded'] + totalGoals['away_goals_conceded']

# Manter apenas as colunas de interesse
totalGoals = totalGoals[['season', 'team_name', 'goals_scored', 'goals_conceded']]

#Adicionar gols marcados e sofridos ao dataframe principal, para os times da casa e visitates
mergedData = pd.merge(mergedData, totalGoals, how='left', left_on=['season', 'home_team_name'], right_on=['season', 'team_name'])
mergedData.rename(columns={'goals_scored': 'home_goals_scored_total', 'goals_conceded': 'home_goals_conceded_total'}, inplace=True)
mergedData.drop('team_name', axis=1, inplace=True)

# Adicionar os gols marcados e sofridos pelos times visitantes
mergedData = pd.merge(mergedData, totalGoals, how='left', left_on=['season', 'away_team_name'], right_on=['season', 'team_name'])
mergedData.rename(columns={'goals_scored': 'away_goals_scored_total', 'goals_conceded': 'away_goals_conceded_total'}, inplace=True)
mergedData.drop('team_name', axis=1, inplace=True)

mergedData.head()

# Calcular pontos para cada time em cada temporada

# 3 pontos por vitória, 1 ponto por empate, 0 por derrota
mergedData['home_team_points'] = mergedData.apply(lambda x: 3 if x['home_team_goal'] > x['away_team_goal'] else (1 if x['home_team_goal'] == x['away_team_goal'] else 0), axis=1)
mergedData['away_team_points'] = mergedData.apply(lambda x: 3 if x['away_team_goal'] > x['home_team_goal'] else (1 if x['away_team_goal'] == x['home_team_goal'] else 0), axis=1)

# Agrupar por temporada e time para somar os pontos totais
homePoints = mergedData.groupby(['season', 'home_team_name'])['home_team_points'].sum().reset_index()
awayPoints = mergedData.groupby(['season', 'away_team_name'])['away_team_points'].sum().reset_index()

# Renomear colunas para facilitar o merge
homePoints.rename(columns={'home_team_name': 'team_name', 'home_team_points': 'points'}, inplace=True)
awayPoints.rename(columns={'away_team_name': 'team_name', 'away_team_points': 'points'}, inplace=True)

# Combinar os pontos de casa e fora em uma única tabela
totalPoints = pd.merge(homePoints, awayPoints, on=['season', 'team_name'], how='outer')
totalPoints['totalPoints'] = totalPoints['points_x'] + totalPoints['points_y']

# Manter apenas as colunas de interesse
totalPoints = totalPoints[['season', 'team_name', 'totalPoints']]

# Identificar o time campeão de cada temporada
champions = totalPoints.loc[totalPoints.groupby('season')['totalPoints'].idxmax()]
champions['is_champion'] = 1

# Adicionar a coluna 'is_champion' ao dataframe original
mergedData = pd.merge(mergedData, champions[['season', 'team_name', 'is_champion']], how='left', left_on=['season', 'home_team_name'], right_on=['season', 'team_name'])

# Preencher os valores NaN da coluna 'is_champion' com 0 (para os times que não foram campeões)
mergedData['is_champion'].fillna(0, inplace=True)

# Remover a coluna 'team_name' que veio do merge
mergedData.drop('team_name', axis=1, inplace=True)

# Dividir entre dados de treino e teste

from sklearn.model_selection import train_test_split

# Selecionar as features (X) e a variável alvo (y)
X = mergedData[['home_goals_scored_total', 'home_goals_conceded_total', 'away_goals_scored_total', 'away_goals_conceded_total', 'is_champion']]  # Ajuste as features de acordo com seus dados
# y = mergedData['is_champion']

# Dividir os dados em treino e teste (80% treino, 20% teste)
X_train, X_test, = train_test_split(X, test_size=0.2, random_state=123)

mergedData.shape
mergedData.head()

#Configurando o setup
cdt = setup(data=X_train,
            target='is_champion',
            test_data=X_test,
            session_id=123,
            index=False)

models()

# Comparar os modelos e encontrar o melhor
best_model = compare_models()

#

rfModel = create_model('rf', n_estimators=100, max_depth=10, min_samples_split=2, fold=5)

plot_model(rfModel, plot='boundary')

plot_model(rfModel, plot='feature')

#Realizar predição
rfTestingPred = predict_model(rfModel, data=X_test)

# Verificando como ficou a predição das observações
rfTestingPred.head()

trueLabels = rfTestingPred['is_champion']
predictedLabels = rfTestingPred['prediction_label']

conf_matrix = confusion_matrix(trueLabels, predictedLabels)

pltfigure(figsize=(10,7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix')
plt.show()

# Calcular acurácia
accuracy = accuracy_score(trueLabels, predictedLabels)

# Calcular coeficiente Kappa
kappa = cohen_kappa_score(trueLabels, predictedLabels)

# Gerar relatório de classificação
classification_rep = classification_report(trueLabels, predictedLabels)

# Exibir as métricas
print(f'Accuracy: {accuracy}')
print(f'Kappa: {kappa}')
print('Classification Report:')
print(classification_rep)

# Tunando o modelo
tunedRf = tune_model(rfModel)

plot_model(tunedRf, plot = 'boundary')

plot_model(tunedRf, plot = 'feature')

plot_model(tunedRf, plot = 'learning')

#Realizar predição do modelo tunado
tunedTfTestingPred = predict_model(tunedRf, data=X_test)

tunedTrueLabels = tunedTfTestingPred['is_champion']
tunedPredictedLabels = tunedTfTestingPred['prediction_label']

conf_matrix = confusion_matrix(tunedTrueLabels, tunedPredictedLabels)

pltfigure(figsize=(10,7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix')
plt.show()

# Calcular acurácia
accuracy = accuracy_score(tunedTrueLabels, tunedPredictedLabels)

# Calcular coeficiente Kappa
kappa = cohen_kappa_score(tunedTrueLabels, tunedPredictedLabels)

# Gerar relatório de classificação
classification_rep = classification_report(tunedTrueLabels, tunedPredictedLabels)

# Exibir as métricas
print(f'Accuracy: {accuracy}')
print(f'Kappa: {kappa}')
print('Classification Report:')
print(classification_rep)

# Para o modelo k-nn
knnModel = create_model('knn', n_neighbors=5, fold=5)

plot_model(knnModel, plot = 'boundary')

plot_model(knnModel, plot = 'learning')

knnTestingPred = predict_model(knnModel, data = X_test)

# Supondo que 'true_labels' seja a coluna de rótulos verdadeiros e 'predicted_labels' a coluna de rótulos previstos
knnTrueLabels = knnTestingPred['is_champion']
knnPredictedLabels = knnTestingPred['prediction_label']

# Calcular a matriz de confusão
conf_matrix = confusion_matrix(knnTrueLabels, knnPredictedLabels)

# Plotar a matriz de confusão
plt.figure(figsize=(10,7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix')
plt.show()

# Calcular acurácia
accuracy = accuracy_score(knnTrueLabels, knnPredictedLabels)

# Calcular coeficiente Kappa
kappa = cohen_kappa_score(knnTrueLabels, knnPredictedLabels)

# Gerar relatório de classificação
classification_rep = classification_report(knnTrueLabels, knnPredictedLabels)

# Exibir as métricas
print(f'Accuracy: {accuracy}')
print(f'Kappa: {kappa}')
print('Classification Report:')
print(classification_rep)